<html>
  <head>
    <title>Fit | Irregular bin packing library by JavaScript</title>
    <link rel='stylesheet' type='text/css' href='./styles/normalize.css'>
    <link rel='stylesheet' type='text/css' href='./styles/demo.css'>
  </head>
  <body>
    <div id='container'>
      <div class='header'>
        <h1>Fit</h1>
        <p>Irregular bin packing library by JavaScript.</p>
        <a href='https://github.com/mattatz/Fit'>View on Github<img src='./images/github.png' /></a>
      </div>
      <div id='indicator'>
        <div style='display: flex; align-items: center; margin-bottom: 8px;'>
          <span class='generation'></span>
          <span class='status'></span>
        </div>
        <div class='scale-bounds'>
          <span class='bounds-info'></span>
        </div>
        <span class='progress'>
          <span class='progress-body'>
          </span>
        </span>
      </div>
      <div id='controller'>
        <ul>
          <li>
            <label for='width'>Width:</label>
            <input id='width' type='number' value='440' min='320' max='500' />
          </li>
          <li>
            <label for='height'>Height:</label>
            <input id='height' type='number' value='220' min='200' max='400' />
          </li>
          <li>
            <label for='spacing'>Spacing:</label>
            <input id='spacing' type='number' value='5' min='0' max='20' />
          </li>
          <li>
            <label for='auto-scale'>
              <input id='auto-scale' type='checkbox' checked />
              Auto-find optimal scale
            </label>
          </li>
          <li>
            <label for='manual-scale'>Manual Scale:</label>
            <input id='manual-scale' type='number' value='0.1' min='0.01' max='0.5' step='0.01' />
          </li>
          <li>
            <button id='reset-button'>Reset</button>
          </li>
        </ul>
      </div>
      <div id='playground'></div>
    </div>
    <script src='/Fit/demo/js/build.js'></script>
    <script>
      let packer = new Fit.Packer()
      let root = document.getElementById('playground')

      // Load sticker polygon from JSON
      async function loadStickerJSON(filename) {
        const response = await fetch(`./stickers/${filename}`)
        return await response.json()
      }

      // Simplify polygon by sampling every nth point
      function simplifyPolygon(contour, sampleRate = 10) {
        return contour.filter((pt, idx) => idx % sampleRate === 0)
      }

      // Convert sticker JSON contour to Fit.Part
      function createStickerPart(id, stickerData, scale = 1, sampleRate = 10, options = {}) {
        // Simplify first, then scale
        let simplified = simplifyPolygon(stickerData.contour, sampleRate)
        let points = simplified.map(pt =>
          new Fit.Vector(pt.x * scale, pt.y * scale)
        )
        return new Fit.Part(id, points, options)
      }

      // Load all sticker shapes
      async function loadAllStickers() {
        const stickerFiles = [
          'JPEG image-digital-cut.json',
          'tmp1o3nlq22-digital-cut.json',
          'tmp5wirhmwj-digital-cut.json',
          'tmprlm_1fcn-digital-cut.json',
          'tmpzadx3jmf-digital-cut.json'
        ]

        const stickers = await Promise.all(
          stickerFiles.map(file => loadStickerJSON(file))
        )

        return stickers
      }

      // Core scale optimization algorithm (reusable)
      async function findOptimalScaleCore(stickers, binWidth, binHeight, config, callbacks = {}) {
        const {
          onProgress = () => {},
          onTestStart = () => {},
          onTestComplete = () => {},
          onComplete = () => {}
        } = callbacks

        let minScale = 0.01
        let maxScale = 0.5
        let bestScale = minScale
        let bestResult = null
        let iterations = 0
        const maxIterations = 20

        return new Promise((resolve) => {
          function testScaleIteration() {
            if (iterations >= maxIterations || (maxScale - minScale) < 0.001) {
              onComplete(bestScale, bestResult, iterations)
              resolve({ scale: bestScale, result: bestResult, iterations })
              return
            }

            iterations++
            let testScale = (minScale + maxScale) / 2

            onTestStart(testScale, iterations, maxIterations)

            // Create parts at this scale
            let parts = stickers.map((stickerData, idx) =>
              createStickerPart(idx, stickerData, testScale, config.sampleRate, config.colors[idx % config.colors.length])
            )

            let bin = new Fit.Bin(0, binWidth, binHeight, { strokeColor: '#aaa', strokeWidth: 2 })
            let testPacker = new Fit.Packer()

            // Run packing with minimal generations for speed
            const packConfig = {
              spacing: config.spacing || 0,
              rotationSteps: config.rotationSteps || 4,
              population: 5,
              generations: 3,
              mutationRate: config.mutationRate || 0.15
            }

            testPacker.start([bin], parts, packConfig, {
              onPackingCompleted: (e) => {
                let fitsInOneBin = e.unplaced.length === 0

                onTestComplete(testScale, fitsInOneBin, e)

                if (fitsInOneBin) {
                  // Fits! Try larger scale
                  bestScale = testScale
                  bestResult = e
                  minScale = testScale
                } else {
                  // Doesn't fit, try smaller scale
                  maxScale = testScale
                }

                onProgress(minScale, maxScale, bestScale)

                // Continue search
                setTimeout(testScaleIteration, 10)
              }
            })
          }

          testScaleIteration()
        })
      }

      // Demo UI wrapper for scale search
      async function findOptimalScale(stickers, binWidth, binHeight, spacing, sampleRate, colors, config) {
        let statusEl = document.getElementsByClassName('status')[0]
        let boundsEl = document.getElementsByClassName('bounds-info')[0]
        let progressBody = document.getElementsByClassName('progress-body')[0]

        console.log('Searching for maximum scale that fits all stickers in one bin...')
        statusEl.innerText = 'Searching...'

        const result = await findOptimalScaleCore(stickers, binWidth, binHeight, {
          spacing,
          sampleRate,
          colors,
          rotationSteps: config.rotationSteps,
          mutationRate: config.mutationRate
        }, {
          onTestStart: (testScale, iteration, maxIterations) => {
            statusEl.innerText = `Testing: ${testScale.toFixed(4)}`
          },
          onTestComplete: (testScale, fits, packResult) => {
            // Color-code progress bar
            progressBody.className = 'progress-body ' + (fits ? 'fits' : 'doesnt-fit')

            let decision = fits ?
              '✓ FITS → try LARGER (increase lower bound)' :
              '✗ TOO BIG → try SMALLER (decrease upper bound)'

            console.log(`Scale ${testScale.toFixed(4)}: ${decision} (${packResult.placed.length} placed, ${packResult.unplaced.length} unplaced)`)

            // Visualize each test result
            visualize(packResult.bins, packResult.placed, packResult.placements, packResult.unplaced, packResult.placed)
          },
          onProgress: (minScale, maxScale, bestScale) => {
            boundsEl.innerHTML = `
              Binary Search:
              <span style="color: #e67e22;">min=${minScale.toFixed(4)}</span> |
              <span style="color: #27ae60;">best=${bestScale.toFixed(4)}</span> |
              <span style="color: #c0392b;">max=${maxScale.toFixed(4)}</span> |
              range=${(maxScale - minScale).toFixed(4)}
            `
          },
          onComplete: (bestScale, bestResult, iterations) => {
            progressBody.className = 'progress-body'
            console.log(`✓ Optimal scale found: ${bestScale.toFixed(4)} after ${iterations} iterations`)
            statusEl.innerText = `Found optimal scale!`
            boundsEl.innerHTML = `
              <span style="color: #27ae60; font-weight: bold;">
                ✓ Optimal scale: ${bestScale.toFixed(4)} (converged in ${iterations} iterations)
              </span>
            `
          }
        })

        return result.scale
      }

      function createDebugRect(id, size = 100, options = {}) {
        let points = []
        points.push(new Fit.Vector(0, size))
        points.push(new Fit.Vector(0, 0))
        points.push(new Fit.Vector(size, 0))
        points.push(new Fit.Vector(size, size))
        return new Fit.Part(id, points, options)
      }

      function createDebugPart(id, vertices = 6, minRadius = 50, maxRadius = 100, dx = 0, dy = 0, options = {}) {
        let points = []

        let interval = maxRadius - minRadius

        for (let i = 0; i < vertices; i++) {
          let r = (i / vertices) * Math.PI * 2
          let x = maxRadius + Math.cos(r) * (Math.random() * interval + minRadius) + dx
          let y = maxRadius + Math.sin(r) * (Math.random() * interval + minRadius) + dy
          points.push(new Fit.Vector(x, y))
        }

        return new Fit.Part(id, points, options)
      }

      let gen = document.getElementsByClassName('generation')[0]
      let progress = document.getElementsByClassName('progress-body')[0]
      let indicator = (e) => {
        gen.innerText = `Generation: ${e.generation}`
        let percent = e.progress * 100
        progress.style.width = `${percent}%`
      }

      let visualize = (bins = [], placed = [], placements = [], unplaced = [], source = []) => {

        while (root.firstChild) {
          root.firstChild.remove()
        }

        bins.forEach((bin, idx) => {
          let svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
          svg.setAttribute('width', bin.width)
          svg.setAttribute('height', bin.height)
          svg.appendChild(bin.toSVG())

          let empty = true
          placements.forEach(placement => {
            if (placement.bin === bin.id) {
              empty = false

              let part = placed.find(p => placement.part === p.id)
              if(part !== undefined) {
                svg.appendChild(part.toSVG())
                // svg.appendChild(part.toTextSVG()) // debug vertices
              }

              /*
              let src = source.find(p => placement.part === p.id)
              if(src !== undefined) {
                let plg = src.clone().rotate(placement.rotation).translate(placement.position.x, placement.position.y)
                svg.appendChild(plg.toSVG())
              }
              */
            }
          })

          if (!empty) {
            root.appendChild(svg)
          }
        })

        if(unplaced.length > 0) {
          let svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
          svg.classList.add('unplaced')
          let aw = root.getBoundingClientRect().width - 10
          // svg.setAttribute('width', w)
          // svg.setAttribute('height', w)

          let bbs = unplaced.map(part => part.bounds())
          let mw = 0, mh = 0
          bbs.forEach(bb => {
            mw = Math.max(bb.width, mw)
            mh = Math.max(bb.height, mh)
          })

          let ox = 0, oy = 0

          unplaced.forEach((part, i) => {
            let bb = bbs[i]
            if (ox + bb.width > aw) {
              ox = 0
              oy += mh
            }
            let el = part.translate(ox, oy).toSVG()
            svg.appendChild(el)

            ox += bb.width
          })

          svg.setAttribute('width', aw)
          svg.setAttribute('height', oy + mh)

          root.appendChild(svg)
        }

      }

      // initial bin size
      let w = Math.floor(root.getBoundingClientRect().width * 0.5) - 20
      document.getElementById('width').value = w
      document.getElementById('height').value = Math.floor(w * 0.5)

      let start = async () => {
        let width = Number(document.getElementById('width').value)
        let height = Number(document.getElementById('height').value)
        let spacing = Number(document.getElementById('spacing').value)
        let autoScale = document.getElementById('auto-scale').checked
        let manualScale = Number(document.getElementById('manual-scale').value)

        let bin = new Fit.Bin(0, width, height, { strokeColor: '#aaa', strokeWidth: 2 })
        let bins = [ bin ]

        // Load sticker shapes
        let stickers = await loadAllStickers()

        // Define color options for variety
        const colors = [
          { strokeColor: '#ff0000', fill: '#ff88aa', strokeWidth: 2 },
          { strokeColor: '#0000ff', fill: '#bbccff', strokeWidth: 2 },
          { strokeColor: '#00ff00', fill: '#88ffaa', strokeWidth: 2 },
          { strokeColor: '#ff00ff', fill: '#ffaaff', strokeWidth: 2 },
          { strokeColor: '#ffaa00', fill: '#ffddaa', strokeWidth: 2 }
        ]

        let sampleRate = 50 // Take every 50th point for simpler polygons (~30 points)

        let config = {
          spacing: spacing || 0,  // space between parts
          rotationSteps: 4,       // # of angles for available rotation (ex. 4 means [0, 90, 180, 270] angles from 360 / 4 )
          population: 10,         // # of population in GA
          generations: 10,        // # of generations in GA
          mutationRate: 0.15      // mutation rate in GA
        }

        // Find optimal scale or use manual scale
        let scale = manualScale
        let searchResult = null
        if (autoScale) {
          searchResult = await findOptimalScaleCore(stickers, width, height, {
            spacing,
            sampleRate,
            colors,
            rotationSteps: config.rotationSteps,
            mutationRate: config.mutationRate
          }, {
            onTestStart: (testScale, iteration, maxIterations) => {
              document.getElementsByClassName('status')[0].innerText = `Testing: ${testScale.toFixed(4)}`
            },
            onTestComplete: (testScale, fits, packResult) => {
              let progressBody = document.getElementsByClassName('progress-body')[0]
              progressBody.className = 'progress-body ' + (fits ? 'fits' : 'doesnt-fit')

              let decision = fits ?
                '✓ FITS → try LARGER (increase lower bound)' :
                '✗ TOO BIG → try SMALLER (decrease upper bound)'

              console.log(`Scale ${testScale.toFixed(4)}: ${decision} (${packResult.placed.length} placed, ${packResult.unplaced.length} unplaced)`)
              visualize(packResult.bins, packResult.placed, packResult.placements, packResult.unplaced, packResult.placed)
            },
            onProgress: (minScale, maxScale, bestScale) => {
              document.getElementsByClassName('bounds-info')[0].innerHTML = `
                Binary Search:
                <span style="color: #e67e22;">min=${minScale.toFixed(4)}</span> |
                <span style="color: #27ae60;">best=${bestScale.toFixed(4)}</span> |
                <span style="color: #c0392b;">max=${maxScale.toFixed(4)}</span> |
                range=${(maxScale - minScale).toFixed(4)}
              `
            },
            onComplete: (bestScale, bestResult, iterations) => {
              document.getElementsByClassName('progress-body')[0].className = 'progress-body'
              console.log(`✓ Optimal scale found: ${bestScale.toFixed(4)} after ${iterations} iterations`)
              document.getElementsByClassName('status')[0].innerText = `Found optimal scale!`
              document.getElementsByClassName('bounds-info')[0].innerHTML = `
                <span style="color: #27ae60; font-weight: bold;">
                  ✓ Optimal scale: ${bestScale.toFixed(4)} (converged in ${iterations} iterations)
                </span>
              `
            }
          })

          scale = searchResult.scale
          document.getElementById('manual-scale').value = scale.toFixed(3)

          // If search found a solution that fits in one bin, use it directly
          if (searchResult.result && searchResult.result.unplaced.length === 0) {
            console.log('Using optimal result from search (all fit in one bin)')
            visualize(searchResult.result.bins, searchResult.result.placed, searchResult.result.placements, searchResult.result.unplaced, searchResult.result.placed)
            return // Don't run packing again
          }
        }

        let parts = []
        // Use all 5 stickers with the determined scale
        stickers.forEach((stickerData, idx) => {
          parts.push(createStickerPart(parts.length, stickerData, scale, sampleRate, colors[idx % colors.length]))
        })

        // visualize([], [], [], parts, parts)

        packer.start(bins, parts, config, {
          onStart: (e) => {
            visualize([], [], [], packer.parts, packer.parts)
          },
          onEvaluation: (e) => {
            indicator(e)
          },
          onPacking: (e) => {
            visualize(e.bins, e.placed, e.placements, e.unplaced, parts)
            if (e.unplaced.length > 0) {
              let last = e.bins[e.bins.length - 1]
              let newBin = new Fit.Bin(last.id + 1, last.width, last.height, { strokeColor: '#aaa', strokeWidth: 2 })
              packer.addBin(newBin)
            }
          },
          onPackingCompleted: (e) => {
            visualize(e.bins, e.placed, e.placements, e.unplaced, parts)
            console.log(e)
          }
        })
      }

      document.getElementById('reset-button').addEventListener('click', (e) => {
        packer.stop()
        start()
      })
      start()

    </script>
  </body>
</html>